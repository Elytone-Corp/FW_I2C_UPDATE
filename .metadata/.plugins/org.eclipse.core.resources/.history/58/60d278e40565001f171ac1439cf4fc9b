

//*********************************STABLE_CODE_STABLE_PWM_DETECT & CLASSIFICATION**************************************



//
//#include <stdio.h>
//#include "mxc_device.h"
//#include "gpio.h"
//#include "tmr.h"
//#include "nvic_table.h"
//#include "mxc_delay.h"
//#include "uart.h"
//
//#define PWM_INPUT_PIN      13  // This is P0_2, connected to the PWM signal
//#define TMR_IDX            0  // Use Timer 0
//
//volatile uint32_t risingEdge1 = 0, fallingEdge = 0, period = 0;
//volatile uint32_t highTime = 0;
//volatile float dutyCycle = 0.0;
//volatile int measurementReady = 0;
//volatile int currentClass = -1;
//
//void PWM_Handler(void* cbdata);
//
//void GPIO_Init(void) {
//    mxc_gpio_cfg_t gpio_cfg_pwm = {
//        .port = MXC_GPIO0,
//        .mask = (1 << PWM_INPUT_PIN),
//        .pad = MXC_GPIO_PAD_NONE,
//        .func = MXC_GPIO_FUNC_IN
//    };
//    MXC_GPIO_Config(&gpio_cfg_pwm);
//
//    // Register and enable interrupts
//    MXC_GPIO_RegisterCallback(&gpio_cfg_pwm, PWM_Handler, NULL);
//    MXC_GPIO_IntConfig(&gpio_cfg_pwm, MXC_GPIO_INT_BOTH);
//    MXC_GPIO_EnableInt(gpio_cfg_pwm.port, gpio_cfg_pwm.mask);
//
//    NVIC_EnableIRQ(MXC_GPIO_GET_IRQ(MXC_GPIO_GET_IDX(MXC_GPIO0)));
//}
//
//void Timer_Init(void) {
//    mxc_tmr_cfg_t tmr_cfg;
//
//    MXC_TMR_Stop(MXC_TMR_GET_TMR(TMR_IDX));
//
//    tmr_cfg.pres = MXC_TMR_PRES_1;
//    tmr_cfg.mode = MXC_TMR_MODE_CONTINUOUS;
//    tmr_cfg.cmp_cnt = 0;
//    tmr_cfg.pol = 0;
//
//    MXC_TMR_Init(MXC_TMR_GET_TMR(TMR_IDX), &tmr_cfg);
//    MXC_TMR_Start(MXC_TMR_GET_TMR(TMR_IDX));
//}
//
//void PWM_Handler(void* cbdata) {
//    uint32_t current_time = MXC_TMR_GetCount(MXC_TMR_GET_TMR(TMR_IDX));
//
//    if (MXC_GPIO_InGet(MXC_GPIO0, (1 << PWM_INPUT_PIN))) {
//        if (risingEdge1 == 0) {
//            risingEdge1 = current_time;
//        } else {
//            period = current_time - risingEdge1;
//            risingEdge1 = current_time;
//            measurementReady = 1;
//        }
//    } else {
//        fallingEdge = current_time;
//        highTime = fallingEdge - risingEdge1;
//    }
//}
//
//void Process_PWM(void) {
//    if (measurementReady) {
//        measurementReady = 0;
//
//        dutyCycle = ((float)highTime / period) * 100.0;
//
//        // Handle possible high duty cycles (near 90%)
//        if (dutyCycle > 95.0) {
//            dutyCycle = 90.0;
//        }
//
//        // Define ranges based on the new logic (I used 4 units)
//        const float requiredDutyCycleRanges[4][2] = {
//            {23.0, 28.0},  // 25% duty cycle range
//            {48.0, 53.0},  // 50% duty cycle range
//            {73.0, 78.0},  // 75% duty cycle range
//            {88.0, 92.0}   // 90% duty cycle range
//        };
//
//        // Classification logic
//        for (int i = 0; i < 4; i++) {
//            if (dutyCycle >= requiredDutyCycleRanges[i][0] && dutyCycle <= requiredDutyCycleRanges[i][1]) {
//                if (i != currentClass) {
//                    float classifiedDuty = (i + 1) * 22.5;
//                    if (i == 0) classifiedDuty = 25;
//                    if (i == 1) classifiedDuty = 50;
//                    if (i == 2) classifiedDuty = 75;
//                    if (i == 3) classifiedDuty = 90;
//
//                    //printf("Measured Duty Cycle: %.2f%%\n", dutyCycle);
//                    printf("----------  ");
//                    printf("Captured Duty Cycle =====>> %.0f%% duty cycle\n", classifiedDuty);
//                    currentClass = i;
//                }
//                break;
//            }
//        }
//    }
//}
//
//int main(void) {
//    GPIO_Init();
//    Timer_Init();
//
//    // Initial classification right after start
//    printf("STARING_____ AT :--> \n\t");
//    Process_PWM();
//
//    while (1) {
//        Process_PWM();
//        MXC_Delay(MXC_DELAY_MSEC(250));
//    }
//
//    return 0;
//}


//==================================================================================================================





#include <stdio.h>
#include "mxc_device.h"
#include "gpio.h"
#include "tmr.h"
#include "nvic_table.h"
#include "mxc_delay.h"
#include "uart.h"
#include "board.h"

#define PWM_INPUT_PIN      13  // P0_13 connected to the PWM signal
#define TMR_IDX            0   // Use Timer 0

#define BUFFER_SIZE        14  // Define the buffer size as 14
#define CLASSIFY_SIZE      4   // We will classify based on the last 4 values

#define NOISE_THRESHOLD 3  // Number of noisy signals allowed before skipping classification
volatile int noiseCounter = 0;

// Define thresholds with slightly wider ranges to accommodate signal variations
#define DUTY_25_LOWER      23.0f
#define DUTY_25_UPPER      28.0f
#define DUTY_50_LOWER      48.0f
#define DUTY_50_UPPER      53.0f
#define DUTY_75_LOWER      73.0f
#define DUTY_75_UPPER      78.0f
#define DUTY_90_LOWER      88.0f
#define DUTY_90_UPPER      92.0f

// Define a tolerance value to allow for flexibility in comparisons
#define TOLERANCE          2.0f  // 2% tolerance for duty cycle comparisons

volatile int buffer[BUFFER_SIZE] = {0};  // Sequential buffer with length 14
volatile int bufferIndex = 0;            // Index to track the current position in the buffer
volatile int bufferReady = 0;            // Flag to indicate when the buffer is full
volatile int detecting = 0;              // Flag to indicate if we're in the detecting phase

volatile uint32_t risingEdge1 = 0, fallingEdge = 0, period = 0;
volatile uint32_t highTime = 0;
volatile float dutyCycle = 0.0;
volatile int measurementReady = 0;

void PWM_Handler(void* cbdata);

void GPIO_Init(void) {
    mxc_gpio_cfg_t gpio_cfg_pwm = {
        .port = MXC_GPIO0,
        .mask = (1 << PWM_INPUT_PIN),
        .pad = MXC_GPIO_PAD_NONE,
        .func = MXC_GPIO_FUNC_IN
    };
    MXC_GPIO_Config(&gpio_cfg_pwm);

    // Register and enable interrupts
    MXC_GPIO_RegisterCallback(&gpio_cfg_pwm, PWM_Handler, NULL);
    MXC_GPIO_IntConfig(&gpio_cfg_pwm, MXC_GPIO_INT_BOTH);
    MXC_GPIO_EnableInt(gpio_cfg_pwm.port, gpio_cfg_pwm.mask);

    NVIC_EnableIRQ(MXC_GPIO_GET_IRQ(MXC_GPIO_GET_IDX(MXC_GPIO0)));
}

void Timer_Init(void) {
    mxc_tmr_cfg_t tmr_cfg;

    MXC_TMR_Stop(MXC_TMR_GET_TMR(TMR_IDX));

    tmr_cfg.pres = MXC_TMR_PRES_1;
    tmr_cfg.mode = MXC_TMR_MODE_CONTINUOUS;
    tmr_cfg.cmp_cnt = 0;
    tmr_cfg.pol = 0;

    MXC_TMR_Init(MXC_TMR_GET_TMR(TMR_IDX), &tmr_cfg);
    MXC_TMR_Start(MXC_TMR_GET_TMR(TMR_IDX));
}

void PWM_Handler(void* cbdata) {
    uint32_t current_time = MXC_TMR_GetCount(MXC_TMR_GET_TMR(TMR_IDX));

    if (MXC_GPIO_InGet(MXC_GPIO0, (1 << PWM_INPUT_PIN))) {
        if (risingEdge1 == 0) {
            risingEdge1 = current_time;
        } else {
            period = current_time - risingEdge1;
            risingEdge1 = current_time;
            measurementReady = 1;
        }
    } else {
        fallingEdge = current_time;
        highTime = fallingEdge - risingEdge1;
    }
}

void classify_and_reset_buffer() {
    // Updated patterns for different classes
    int class4_pattern[CLASSIFY_SIZE] = {90, 50, 25, 25};  // The last 4 values to consider
    int class5_pattern[CLASSIFY_SIZE] = {90, 50, 50, 50};
    int class6_pattern[CLASSIFY_SIZE] = {90, 50, 50, 75};
    int class7_pattern[CLASSIFY_SIZE] = {90, 50, 75, 50};
    int class8_pattern[CLASSIFY_SIZE] = {90, 50, 75, 75};

    int detectedClass = -1;

    // Extract the last 4 values from the buffer
    int last_values[CLASSIFY_SIZE];
    for (int i = 0; i < CLASSIFY_SIZE; i++) {
        last_values[i] = buffer[BUFFER_SIZE - CLASSIFY_SIZE + i];
    }

    // Tolerance value to allow some variation in the comparison
    int tolerance = 5;  // Allow for +/- 5% variation in duty cycle

    // Helper function to check if a value is within the tolerance range
    int within_tolerance(int actual, int expected) {
        return (actual >= expected - tolerance) && (actual <= expected + tolerance);
    }

    // Compare the last 4 values with each class pattern using tolerance
    int matchClass4 = 1, matchClass5 = 1, matchClass6 = 1, matchClass7 = 1, matchClass8 = 1;
    for (int i = 0; i < CLASSIFY_SIZE; i++) {
        if (!within_tolerance(last_values[i], class4_pattern[i])) matchClass4 = 0;
        if (!within_tolerance(last_values[i], class5_pattern[i])) matchClass5 = 0;
        if (!within_tolerance(last_values[i], class6_pattern[i])) matchClass6 = 0;
        if (!within_tolerance(last_values[i], class7_pattern[i])) matchClass7 = 0;
        if (!within_tolerance(last_values[i], class8_pattern[i])) matchClass8 = 0;
    }

    // Determine which class the last 4 values match
    if (matchClass4) detectedClass = 4;
    else if (matchClass5) detectedClass = 5;
    else if (matchClass6) detectedClass = 6;
    else if (matchClass7) detectedClass = 7;
    else if (matchClass8) detectedClass = 8;

    // Output the result
    if (detectedClass != -1) {
        printf("\t--------Classified as Class %d--------\n", detectedClass);
    } else {
        printf("No matching class detected.\n");
    }

    // Print the buffer for debugging
    printf("Buffer contents: ");
    for (int i = 0; i < BUFFER_SIZE; i++) {
        printf("%d ", buffer[i]);
    }
    printf("\n");

    // Reset the buffer and index for the next window
    for (int i = 0; i < BUFFER_SIZE; i++) {
        buffer[i] = 0;
    }
    bufferIndex = 0;
    bufferReady = 0;  // Reset the flag
    detecting = 0;    // Go back to waiting for the next trigger
}

typedef enum {
    STATE_IDLE,
    STATE_FILL_BUFFER,
    STATE_CLASSIFY,
    STATE_NOISY
} State;

State currentState = STATE_IDLE;

void Process_PWM(void) {
    if (measurementReady && !bufferReady) {
        measurementReady = 0;

        dutyCycle = ((float)highTime / period) * 100.0;

        switch (currentState) {
            case STATE_IDLE:
                // Wait for the 90% duty cycle to start detecting
                if (dutyCycle >= 88.0 && dutyCycle <= 92.0) {
                    printf("Detected 90%% duty cycle. Starting buffer...\n");
                    detecting = 1;  // Start detecting subsequent events
                    buffer[0] = 90; // Store the 90% as the first entry
                    bufferIndex = 1;
                    currentState = STATE_FILL_BUFFER;
                }
                break;

            case STATE_FILL_BUFFER:
                // Continue filling the buffer once detecting is triggered
                if (detecting && bufferIndex < BUFFER_SIZE) {
                    if (dutyCycle >= 23.0 && dutyCycle <= 28.0) {
                        buffer[bufferIndex++] = 25;  // 25% duty cycle
                        printf("Buffer[%d] = 25\n", bufferIndex - 1);
                        noiseCounter = 0;  // Reset noise counter on valid signal
                    } else if (dutyCycle >= 48.0 && dutyCycle <= 53.0) {
                        buffer[bufferIndex++] = 50;  // 50% duty cycle
                        printf("Buffer[%d] = 50\n", bufferIndex - 1);
                        noiseCounter = 0;  // Reset noise counter on valid signal
                    } else if (dutyCycle >= 73.0 && dutyCycle <= 78.0) {
                        buffer[bufferIndex++] = 75;  // 75% duty cycle
                        printf("Buffer[%d] = 75\n", bufferIndex - 1);
                        noiseCounter = 0;  // Reset noise counter on valid signal
                    } else {
                        // If duty cycle is outside valid ranges, increment noise counter
                        noiseCounter++;
                        printf("Detected noise. Noise counter: %d\n", noiseCounter);

                        // If too much noise, skip classification
                        if (noiseCounter >= NOISE_THRESHOLD) {
                            printf("Too much noise detected. Skipping classification.\n");
                            currentState = STATE_NOISY;
                        }
                    }

                    // If buffer is full, transition to classify state
                    if (bufferIndex == BUFFER_SIZE) {
                        bufferReady = 1;
                        currentState = STATE_CLASSIFY;
                    }
                }
                break;

            case STATE_CLASSIFY:
                // Classify and reset the buffer
                classify_and_reset_buffer();
                currentState = STATE_IDLE;
                noiseCounter = 0;  // Reset noise counter after classification
                break;

            case STATE_NOISY:
                // Skip the current classification attempt and reset
                bufferIndex = 0;
                detecting = 0;
                bufferReady = 0;
                noiseCounter = 0;  // Reset noise counter after noise detection
                currentState = STATE_IDLE;
                break;
        }
    }
}

int main(void) {
	MXC_Delay(MXC_DELAY_MSEC(2));
    GPIO_Init();
    Timer_Init();

    // Main loop
    while (1) {
        if (bufferReady) {
            classify_and_reset_buffer();
        }

        Process_PWM();
        MXC_Delay(MXC_DELAY_MSEC(10));
    }

    return 0;
}
