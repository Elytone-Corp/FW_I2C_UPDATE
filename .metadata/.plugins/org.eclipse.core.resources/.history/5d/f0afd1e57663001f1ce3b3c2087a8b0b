

//*********************************STABLE_CODE_STABLE_PWM_DETECT & CLASSIFICATION**************************************


//
//
//#include <stdio.h>
//#include "mxc_device.h"
//#include "gpio.h"
//#include "tmr.h"
//#include "nvic_table.h"
//#include "mxc_delay.h"
//#include "uart.h"
//
//#define PWM_INPUT_PIN      2  // This is P0_2, connected to the PWM signal
//#define BUTTON_PIN         1  // Button connected to P0_1
//#define TMR_IDX            0  // Use Timer 0
//
//volatile uint32_t risingEdge1 = 0, fallingEdge = 0, period = 0;
//volatile uint32_t highTime = 0;
//volatile float dutyCycle = 0.0;
//volatile int measurementReady = 0;
//volatile int currentClass = -1;
//volatile int classificationLocked = 0;
//volatile int buttonPressed = 0;
//volatile uint32_t debounceTime = 0;
//
//void PWM_Handler(void* cbdata);
//void Button_Handler(void* cbdata);
//
//void GPIO_Init(void) {
//    mxc_gpio_cfg_t gpio_cfg_pwm = {
//        .port = MXC_GPIO0,
//        .mask = (1 << PWM_INPUT_PIN),
//        .pad = MXC_GPIO_PAD_NONE,
//        .func = MXC_GPIO_FUNC_IN
//    };
//    MXC_GPIO_Config(&gpio_cfg_pwm);
//
//    mxc_gpio_cfg_t gpio_cfg_button = {
//        .port = MXC_GPIO0,
//        .mask = (1 << BUTTON_PIN),
//        .pad = MXC_GPIO_PAD_PULL_UP,
//        .func = MXC_GPIO_FUNC_IN
//    };
//    MXC_GPIO_Config(&gpio_cfg_button);
//
//    // Register and enable interrupts
//    MXC_GPIO_RegisterCallback(&gpio_cfg_pwm, PWM_Handler, NULL);
//    MXC_GPIO_IntConfig(&gpio_cfg_pwm, MXC_GPIO_INT_BOTH);
//    MXC_GPIO_EnableInt(gpio_cfg_pwm.port, gpio_cfg_pwm.mask);
//
//    MXC_GPIO_RegisterCallback(&gpio_cfg_button, Button_Handler, NULL);
//    MXC_GPIO_IntConfig(&gpio_cfg_button, MXC_GPIO_INT_FALLING);
//    MXC_GPIO_EnableInt(gpio_cfg_button.port, gpio_cfg_button.mask);
//
//    NVIC_EnableIRQ(MXC_GPIO_GET_IRQ(MXC_GPIO_GET_IDX(MXC_GPIO0)));
//}
//
//void Timer_Init(void) {
//    mxc_tmr_cfg_t tmr_cfg;
//
//    MXC_TMR_Stop(MXC_TMR_GET_TMR(TMR_IDX));
//
//    tmr_cfg.pres = MXC_TMR_PRES_1;
//    tmr_cfg.mode = MXC_TMR_MODE_CONTINUOUS;
//    tmr_cfg.cmp_cnt = 0;
//    tmr_cfg.pol = 0;
//
//    MXC_TMR_Init(MXC_TMR_GET_TMR(TMR_IDX), &tmr_cfg);
//    MXC_TMR_Start(MXC_TMR_GET_TMR(TMR_IDX));
//}
//
//void PWM_Handler(void* cbdata) {
//    uint32_t current_time = MXC_TMR_GetCount(MXC_TMR_GET_TMR(TMR_IDX));
//
//    if (MXC_GPIO_InGet(MXC_GPIO0, (1 << PWM_INPUT_PIN))) {
//        if (risingEdge1 == 0) {
//            risingEdge1 = current_time;
//        } else {
//            period = current_time - risingEdge1;
//            risingEdge1 = current_time;
//            measurementReady = 1;
//        }
//    } else {
//        fallingEdge = current_time;
//        highTime = fallingEdge - risingEdge1;
//    }
//}
//
//void Button_Handler(void* cbdata) {
//    if (!buttonPressed) {
//        buttonPressed = 1;
//        debounceTime = MXC_TMR_GetCount(MXC_TMR_GET_TMR(TMR_IDX));
//    } else if (buttonPressed && (MXC_TMR_GetCount(MXC_TMR_GET_TMR(TMR_IDX)) - debounceTime > 10000)) {
//        if (classificationLocked) {
//            classificationLocked = 0;
//            currentClass = -1;
//            buttonPressed = 0;
//        }
//    }
//}
//
//void Process_PWM(void) {
//    if (measurementReady) {
//        measurementReady = 0;
//
//        dutyCycle = ((float)highTime / period) * 100.0;
//
//        // Handle possible high duty cycles (near 90%)
//        if (dutyCycle > 95.0) {
//            dutyCycle = 90.0;
//        }
//
//        // Define ranges based on the new logic (I used 4 units)
//        const float requiredDutyCycleRanges[4][2] = {
//            {23.0, 28.0},  // 25% duty cycle range
//            {48.0, 53.0},  // 50% duty cycle range
//            {73.0, 78.0},  // 75% duty cycle range
//            {88.0, 92.0}   // 90% duty cycle range
//        };
//
//        // Classification logic
//        for (int i = 0; i < 4; i++) {
//            if (dutyCycle >= requiredDutyCycleRanges[i][0] && dutyCycle <= requiredDutyCycleRanges[i][1]) {
//                if (i != currentClass) {
//                    float classifiedDuty = (i + 1) * 22.5;
//                    if (i == 0) classifiedDuty = 25;
//                    if (i == 1) classifiedDuty = 50;
//                    if (i == 2) classifiedDuty = 75;
//                    if (i == 3) classifiedDuty = 90;
//
//                    printf("Measured Duty Cycle: %.2f%%\n", dutyCycle);
//                    printf("----------  ");
//                    printf("Classified as =====>> %.0f%% duty cycle\n", classifiedDuty);
//                    currentClass = i;
//                    classificationLocked = 1;
//                }
//                break;
//            }
//        }
//    }
//}
//
//int main(void) {
//    GPIO_Init();
//    Timer_Init();
//
//    // Initial classification right after start
//    printf("STARING_____ AT :--> \n");
//    Process_PWM();
//
//    while (1) {
//        if (!classificationLocked) {
//            Process_PWM();
//        }
//        MXC_Delay(MXC_DELAY_MSEC(250));
//    }
//
//    return 0;
//}

//*********************************************-----**********************************************************


// CAPTURE PATERN in SEQUENCE PWM --------

#include <stdio.h>
#include "mxc_device.h"
#include "gpio.h"
#include "tmr.h"
#include "nvic_table.h"
#include "uart.h"

// Define the GPIO pin for PWM input (Pin 13)
#define PWM_INPUT_PIN  (13)

// Variables to hold the high and total times in microseconds
volatile uint32_t high_time = 0;
volatile uint32_t total_time = 0;
volatile uint8_t pwm_signal_ready = 0;

// Timer frequency (set to 1 MHz to measure time in microseconds)
#define TIMER_FREQUENCY 1000000  // 1 MHz

void tmr_callback()
{
    // Capture the high and total times using Timer
    static uint32_t last_time = 0;
    uint32_t current_time = MXC_TMR_GetCapture(MXC_TMR0);
    uint32_t time_diff = current_time - last_time;
    last_time = current_time;

    if (MXC_GPIO_InGet(MXC_GPIO0, PWM_INPUT_PIN)) {
        high_time += time_diff;
    }
    total_time += time_diff;

    if (total_time >= TIMER_FREQUENCY) {  // Capture 1 second worth of data
        pwm_signal_ready = 1;
        MXC_TMR_Stop(MXC_TMR0);
    }
}

void setup_pwm_input()
{
    // Configure GPIO Pin 13 as an input for PWM
    mxc_gpio_cfg_t gpio_cfg_pwm_input;
    gpio_cfg_pwm_input.port = MXC_GPIO0;
    gpio_cfg_pwm_input.mask = (1 << PWM_INPUT_PIN);
    gpio_cfg_pwm_input.pad = MXC_GPIO_PAD_NONE;
    gpio_cfg_pwm_input.func = MXC_GPIO_FUNC_IN;
    gpio_cfg_pwm_input.vssel = MXC_GPIO_VSSEL_VDDIOH;
    MXC_GPIO_Config(&gpio_cfg_pwm_input);

    // Configure Timer with a 1 MHz frequency (1 microsecond per tick)
    mxc_tmr_cfg_t tmr_cfg;
    tmr_cfg.pres = TMR_PRES_8;  // Set prescaler to achieve 1 MHz timer frequency
    tmr_cfg.mode = TMR_MODE_CONTINUOUS;
    tmr_cfg.cmp_cnt = 0;
    tmr_cfg.pol = 0;

    MXC_TMR_Init(MXC_TMR0, &tmr_cfg);

    // Enable interrupt for Timer
    MXC_NVIC_SetVector(TMR0_IRQn, tmr_callback);
    NVIC_EnableIRQ(TMR0_IRQn);

    // Start Timer
    MXC_TMR_Start(MXC_TMR0);
}

void setup_uart()
{
    // Configure UART for output
    if (MXC_UART_Init(MXC_UART0, 115200, MAP_A) != E_NO_ERROR) {
        printf("UART initialization failed!\n");
    }
}

int main(void)
{
    // Initialize the system and peripherals
    SystemInit();

    // Setup GPIO for PWM input and UART for output
    setup_pwm_input();
    setup_uart();

    printf("PWM Duty Cycle Observation Program Started\n");

    while (1) {
        if (pwm_signal_ready) {
            pwm_signal_ready = 0;

            // Calculate and print the duty cycle
            float duty_cycle = ((float)high_time / total_time) * 100.0f;
            printf("Duty Cycle: %.2f%%\n", duty_cycle);

            // Reset the timers for the next cycle
            high_time = 0;
            total_time = 0;

            // Restart Timer for next cycle
            MXC_TMR_Start(MXC_TMR0);
        }
    }
}
