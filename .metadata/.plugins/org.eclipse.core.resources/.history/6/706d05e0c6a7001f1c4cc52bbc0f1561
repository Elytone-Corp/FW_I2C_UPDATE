#include "i2c_driver.h"
#include <stdio.h>
#include <stdint.h>
#include <stdbool.h>
#include <string.h>

// Slave I2C address
#define SLAVE_I2C_ADDRESS 0x55

// Bootloader commands
#define CMD_START_UPDATE    0x01
#define CMD_ERASE_PARTITION 0x02
#define CMD_PROGRAM_PAGE    0x03
#define CMD_VALIDATE_CRC    0x04
#define CMD_MARK_ACTIVE     0x05
#define CMD_REBOOT          0x06

// Firmware update configuration
#define CHUNK_SIZE 1024
#define PARTITION_SIZE 0x1C000

// Simulated firmware data
uint8_t firmware_data[PARTITION_SIZE] = { /* Populate with firmware bytes */ };

// Retry configuration
#define I2C_RETRY_COUNT 3

// Function prototypes
bool Master_SendCommand(uint8_t command, const uint8_t* payload, uint32_t payload_size, uint8_t* response);
void FirmwareUpdateProcess(void);

int main(void) {
    printf("[Master] Initializing I2C master...\n");
    I2C_Master_Init(SLAVE_I2C_ADDRESS);

    printf("[Master] Starting firmware update process...\n");
    FirmwareUpdateProcess();

    printf("[Master] Firmware update process completed.\n");
    I2C_Master_Deinit();
    return 0;
}

void FirmwareUpdateProcess(void) {
    uint8_t response;

    // Step 1: Start firmware update
    if (!Master_SendCommand(CMD_START_UPDATE, NULL, 0, &response) || response != 0x00) {
        printf("[Master] Error: Failed to start update.\n");
        return;
    }

    // Step 2: Erase partition
    if (!Master_SendCommand(CMD_ERASE_PARTITION, NULL, 0, &response) || response != 0x00) {
        printf("[Master] Error: Failed to erase partition.\n");
        return;
    }

    // Step 3: Program firmware
    uint32_t offset = 0;
    while (offset < PARTITION_SIZE) {
        uint8_t chunk[CHUNK_SIZE];
        uint32_t chunk_size = (offset + CHUNK_SIZE <= PARTITION_SIZE) ? CHUNK_SIZE : (PARTITION_SIZE - offset);
        memcpy(chunk, &firmware_data[offset], chunk_size);

        if (!Master_SendCommand(CMD_PROGRAM_PAGE, chunk, chunk_size, &response) || response != 0x00) {
            printf("[Master] Error: Programming failed at offset 0x%08X.\n", offset);
            return;
        }

        offset += chunk_size;
    }

    // Step 4: Validate CRC
    if (!Master_SendCommand(CMD_VALIDATE_CRC, NULL, 0, &response) || response != 0x00) {
        printf("[Master] Error: CRC validation failed.\n");
        return;
    }

    // Step 5: Mark active
    if (!Master_SendCommand(CMD_MARK_ACTIVE, NULL, 0, &response) || response != 0x00) {
        printf("[Master] Error: Failed to mark partition as active.\n");
        return;
    }

    // Step 6: Reboot slave
    if (!Master_SendCommand(CMD_REBOOT, NULL, 0, &response) || response != 0x00) {
        printf("[Master] Error: Failed to reboot slave.\n");
        return;
    }

    printf("[Master] Firmware update completed successfully!\n");
}

// Helper to send commands to the slave
bool Master_SendCommand(uint8_t command, const uint8_t* payload, uint32_t payload_size, uint8_t* response) {
    uint8_t tx_buffer[CHUNK_SIZE + 1];
    tx_buffer[0] = command;

    if (payload && payload_size > 0) {
        memcpy(&tx_buffer[1], payload, payload_size);
    }

    for (int attempt = 0; attempt < I2C_RETRY_COUNT; attempt++) {
        if (I2C_Send(tx_buffer, payload_size + 1) == I2C_SUCCESS) {
            if (I2C_Receive(response, 1) == I2C_SUCCESS) {
                return true;
            }
        }
        printf("[Master] Retrying command: 0x%02X (Attempt %d)\n", command, attempt + 1);
    }

    printf("[Master] Failed to send command: 0x%02X\n", command);
    return false;
}
