/******************************************************************************
 *
 * Copyright (C) 2022-2023 Maxim Integrated Products, Inc. (now owned by 
 * Analog Devices, Inc.),
 * Copyright (C) 2023-2024 Analog Devices, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 ******************************************************************************/

/**
 * @file        main.c
 * @brief       I2C Master-Slave Transaction
 */


#include <stdio.h>
#include <stdint.h>
#include <string.h>
#include "mxc_device.h"
#include "mxc_delay.h"
#include "i2c.h"
#include "flc.h"
#include "nvic_table.h"
#include "board.h"

#define I2C_SLAVE           MXC_I2C1
#define SLAVE_ADDR          0x55
#define PAGE_SIZE           128
#define FIRMWARE_SIZE       512
#define FLASH_BASE_ADDR     0x10000  // Example firmware base address in flash
#define BOOT_FLAG_ADDR      0x1FF00  // Address to store boot flag

uint8_t rx_buffer[PAGE_SIZE];
uint8_t firmware[FIRMWARE_SIZE];
volatile int rx_flag = 0;
volatile size_t current_offset = 0;

// CRC32 lookup table
uint32_t crc32_table[256];

// Function to initialize the CRC32 lookup table
void init_crc32_table(void) {
    uint32_t crc;
    for (uint32_t i = 0; i < 256; i++) {
        crc = i;
        for (uint32_t j = 0; j < 8; j++) {
            if (crc & 1) {
                crc = (crc >> 1) ^ 0xEDB88320;  // Polynomial
            } else {
                crc >>= 1;
            }
        }
        crc32_table[i] = crc;
    }
}

// Function to calculate the CRC32 checksum
uint32_t calculate_crc32(uint8_t *data, size_t len) {
    uint32_t crc = 0xFFFFFFFF;  // Initial value

    for (size_t i = 0; i < len; i++) {
        uint8_t index = (crc ^ data[i]) & 0xFF;
        crc = (crc >> 8) ^ crc32_table[index];
    }

    return ~crc;  // Final XOR value
}

// Callback function for I2C transaction
void i2c_callback(mxc_i2c_req_t *req, int error) {
    if (error != E_NO_ERROR) {
        printf("I2C Error in Callback: %d\n", error);
    } else {
        printf("Received chunk of data\n");
        rx_flag = 1;  // Signal the reception of data
    }
}

// Flash firmware chunk to memory
void flash_program_chunk(uint32_t addr, uint8_t *data, size_t len) {
    int status = MXC_FLC_Write(addr, (uint32_t*)data, len);
    if (status != E_NO_ERROR) {
        printf("Error writing to flash at address 0x%08X\n", addr);
    }
}

// Validate firmware with CRC
int validate_firmware(void) {
    printf("Validating firmware...\n");
    uint32_t calculated_crc = calculate_crc32(firmware, FIRMWARE_SIZE);
    uint32_t expected_crc = 0x12345678;  // Replace this with actual expected CRC from the master

    if (calculated_crc == expected_crc) {
        printf("Firmware validation successful.\n");
        return 1;
    } else {
        printf("Firmware validation failed. Calculated CRC: 0x%08X\n", calculated_crc);
        return 0;
    }
}

// Initialize I2C slave
void i2c_slave_init(void) {
    printf("Initializing I2C Slave...\n");

    MXC_I2C_Init(I2C_SLAVE, 1, 0);
    MXC_I2C_SetSlaveAddr(I2C_SLAVE, SLAVE_ADDR,0);
    MXC_I2C_SetFrequency(I2C_SLAVE, 100000);  // Set to 100 kHz

    mxc_i2c_req_t i2c_req;
    i2c_req.addr = SLAVE_ADDR;
    i2c_req.tx_buf = NULL;
    i2c_req.tx_len = 0;
    i2c_req.rx_buf = rx_buffer;
    i2c_req.rx_len = PAGE_SIZE;
    i2c_req.restart = 0;
    i2c_req.callback = i2c_callback;

    MXC_I2C_SlaveTransactionAsync(I2C_SLAVE, &i2c_req);
}

// Firmware reception and update process
void receive_firmware(void) {
    while (current_offset < FIRMWARE_SIZE) {
        if (rx_flag) {
            rx_flag = 0;  // Reset flag

            // Copy received data into firmware buffer
            memcpy(&firmware[current_offset], rx_buffer, PAGE_SIZE);

            // Flash data to memory
            flash_program_chunk(FLASH_BASE_ADDR + current_offset, rx_buffer, PAGE_SIZE);

            current_offset += PAGE_SIZE;

            // Reinitialize I2C to prepare for next chunk
            i2c_slave_init();
        }
    }

    printf("Firmware reception completed.\n");

    if (validate_firmware()) {
        // Set boot flag
        uint32_t boot_flag = 0xAABBCCDD;
        MXC_FLC_Write(BOOT_FLAG_ADDR, &boot_flag, sizeof(boot_flag));

        printf("Rebooting to new firmware...\n");
        NVIC_SystemReset();
    } else {
        printf("Firmware validation failed.\n");
    }
}

int main(void) {
    printf("Starting I2C Slave Program for Firmware Update...\n");

    init_crc32_table();  // Initialize CRC32 table
    i2c_slave_init();
    receive_firmware();

    return 0;
}































































