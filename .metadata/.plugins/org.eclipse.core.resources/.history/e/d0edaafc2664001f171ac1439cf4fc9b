

//*********************************STABLE_CODE_STABLE_PWM_DETECT & CLASSIFICATION**************************************



//
//#include <stdio.h>
//#include "mxc_device.h"
//#include "gpio.h"
//#include "tmr.h"
//#include "nvic_table.h"
//#include "mxc_delay.h"
//#include "uart.h"
//
//#define PWM_INPUT_PIN      13  // This is P0_2, connected to the PWM signal
//#define TMR_IDX            0  // Use Timer 0
//
//volatile uint32_t risingEdge1 = 0, fallingEdge = 0, period = 0;
//volatile uint32_t highTime = 0;
//volatile float dutyCycle = 0.0;
//volatile int measurementReady = 0;
//volatile int currentClass = -1;
//
//void PWM_Handler(void* cbdata);
//
//void GPIO_Init(void) {
//    mxc_gpio_cfg_t gpio_cfg_pwm = {
//        .port = MXC_GPIO0,
//        .mask = (1 << PWM_INPUT_PIN),
//        .pad = MXC_GPIO_PAD_NONE,
//        .func = MXC_GPIO_FUNC_IN
//    };
//    MXC_GPIO_Config(&gpio_cfg_pwm);
//
//    // Register and enable interrupts
//    MXC_GPIO_RegisterCallback(&gpio_cfg_pwm, PWM_Handler, NULL);
//    MXC_GPIO_IntConfig(&gpio_cfg_pwm, MXC_GPIO_INT_BOTH);
//    MXC_GPIO_EnableInt(gpio_cfg_pwm.port, gpio_cfg_pwm.mask);
//
//    NVIC_EnableIRQ(MXC_GPIO_GET_IRQ(MXC_GPIO_GET_IDX(MXC_GPIO0)));
//}
//
//void Timer_Init(void) {
//    mxc_tmr_cfg_t tmr_cfg;
//
//    MXC_TMR_Stop(MXC_TMR_GET_TMR(TMR_IDX));
//
//    tmr_cfg.pres = MXC_TMR_PRES_1;
//    tmr_cfg.mode = MXC_TMR_MODE_CONTINUOUS;
//    tmr_cfg.cmp_cnt = 0;
//    tmr_cfg.pol = 0;
//
//    MXC_TMR_Init(MXC_TMR_GET_TMR(TMR_IDX), &tmr_cfg);
//    MXC_TMR_Start(MXC_TMR_GET_TMR(TMR_IDX));
//}
//
//void PWM_Handler(void* cbdata) {
//    uint32_t current_time = MXC_TMR_GetCount(MXC_TMR_GET_TMR(TMR_IDX));
//
//    if (MXC_GPIO_InGet(MXC_GPIO0, (1 << PWM_INPUT_PIN))) {
//        if (risingEdge1 == 0) {
//            risingEdge1 = current_time;
//        } else {
//            period = current_time - risingEdge1;
//            risingEdge1 = current_time;
//            measurementReady = 1;
//        }
//    } else {
//        fallingEdge = current_time;
//        highTime = fallingEdge - risingEdge1;
//    }
//}
//
//void Process_PWM(void) {
//    if (measurementReady) {
//        measurementReady = 0;
//
//        dutyCycle = ((float)highTime / period) * 100.0;
//
//        // Handle possible high duty cycles (near 90%)
//        if (dutyCycle > 95.0) {
//            dutyCycle = 90.0;
//        }
//
//        // Define ranges based on the new logic (I used 4 units)
//        const float requiredDutyCycleRanges[4][2] = {
//            {23.0, 28.0},  // 25% duty cycle range
//            {48.0, 53.0},  // 50% duty cycle range
//            {73.0, 78.0},  // 75% duty cycle range
//            {88.0, 92.0}   // 90% duty cycle range
//        };
//
//        // Classification logic
//        for (int i = 0; i < 4; i++) {
//            if (dutyCycle >= requiredDutyCycleRanges[i][0] && dutyCycle <= requiredDutyCycleRanges[i][1]) {
//                if (i != currentClass) {
//                    float classifiedDuty = (i + 1) * 22.5;
//                    if (i == 0) classifiedDuty = 25;
//                    if (i == 1) classifiedDuty = 50;
//                    if (i == 2) classifiedDuty = 75;
//                    if (i == 3) classifiedDuty = 90;
//
//                    //printf("Measured Duty Cycle: %.2f%%\n", dutyCycle);
//                    printf("----------  ");
//                    printf("Captured Duty Cycle =====>> %.0f%% duty cycle\n", classifiedDuty);
//                    currentClass = i;
//                }
//                break;
//            }
//        }
//    }
//}
//
//int main(void) {
//    GPIO_Init();
//    Timer_Init();
//
//    // Initial classification right after start
//    printf("STARING_____ AT :--> \n\t");
//    Process_PWM();
//
//    while (1) {
//        Process_PWM();
//        MXC_Delay(MXC_DELAY_MSEC(250));
//    }
//
//    return 0;
//}


//==================================================================================================================




#include <stdio.h>
#include "mxc_device.h"
#include "gpio.h"
#include "tmr.h"
#include "nvic_table.h"
#include "mxc_delay.h"
#include "uart.h"
#include <stdlib.h>


#define PWM_INPUT_PIN      13  // This is P0_2, connected to the PWM signal
#define TMR_IDX            0  // Use Timer 0

volatile uint32_t risingEdge1 = 0, fallingEdge = 0, period = 0;
volatile uint32_t highTime = 0;
volatile float dutyCycle = 0.0;
volatile int measurementReady = 0;
volatile int currentClass = -1;

typedef enum {
    DETECT_START_BIT,
    CAPTURE_SEQUENCE,
    IGNORE_PHASE,
    WAIT_FOR_REPEAT
} system_state_t;

system_state_t current_state = DETECT_START_BIT;
float duty_cycles[4];
int duty_cycle_index = 0;

// Debouncing threshold for noise reduction
#define DEBOUNCE_THRESHOLD 2
float lastDutyCycle = 0;

void PWM_Handler(void* cbdata);

void GPIO_Init(void) {
    mxc_gpio_cfg_t gpio_cfg_pwm = {
        .port = MXC_GPIO0,
        .mask = (1 << PWM_INPUT_PIN),
        .pad = MXC_GPIO_PAD_NONE,
        .func = MXC_GPIO_FUNC_IN
    };
    MXC_GPIO_Config(&gpio_cfg_pwm);

    // Register and enable interrupts
    MXC_GPIO_RegisterCallback(&gpio_cfg_pwm, PWM_Handler, NULL);
    MXC_GPIO_IntConfig(&gpio_cfg_pwm, MXC_GPIO_INT_BOTH);
    MXC_GPIO_EnableInt(gpio_cfg_pwm.port, gpio_cfg_pwm.mask);

    NVIC_EnableIRQ(MXC_GPIO_GET_IRQ(MXC_GPIO_GET_IDX(MXC_GPIO0)));
}

void Timer_Init(void) {
    mxc_tmr_cfg_t tmr_cfg;

    MXC_TMR_Stop(MXC_TMR_GET_TMR(TMR_IDX));

    tmr_cfg.pres = MXC_TMR_PRES_1;
    tmr_cfg.mode = MXC_TMR_MODE_CONTINUOUS;
    tmr_cfg.cmp_cnt = 0;
    tmr_cfg.pol = 0;

    MXC_TMR_Init(MXC_TMR_GET_TMR(TMR_IDX), &tmr_cfg);
    MXC_TMR_Start(MXC_TMR_GET_TMR(TMR_IDX));
}

void PWM_Handler(void* cbdata) {
    uint32_t current_time = MXC_TMR_GetCount(MXC_TMR_GET_TMR(TMR_IDX));

    if (MXC_GPIO_InGet(MXC_GPIO0, (1 << PWM_INPUT_PIN))) {
        if (risingEdge1 == 0) {
            risingEdge1 = current_time;
        } else {
            period = current_time - risingEdge1;
            risingEdge1 = current_time;
            measurementReady = 1;
        }
    } else {
        fallingEdge = current_time;
        highTime = fallingEdge - risingEdge1;
    }
}

void classify_pd_class(float duty_cycles[]) {
    // Classify based on the duty cycle sequence
    if (duty_cycles[0] == 25 && duty_cycles[1] == 25 && duty_cycles[2] == 25 && duty_cycles[3] == 90) {
        printf("Classified as ==> CLASS 4\n");
    } else if (duty_cycles[0] == 25 && duty_cycles[1] == 50 && duty_cycles[2] == 50 && duty_cycles[3] == 90) {
        printf("Classified as ==> CLASS 5\n");
    } else if (duty_cycles[0] == 25 && duty_cycles[1] == 50 && duty_cycles[2] == 75 && duty_cycles[3] == 90) {
        printf("Classified as ==> CLASS 6\n");
    } else if (duty_cycles[0] == 25 && duty_cycles[1] == 75 && duty_cycles[2] == 50 && duty_cycles[3] == 90) {
        printf("Classified as ==> CLASS 7\n");
    } else if (duty_cycles[0] == 25 && duty_cycles[1] == 75 && duty_cycles[2] == 75 && duty_cycles[3] == 90) {
        printf("Classified as ==> CLASS 8\n");
    } else {
        printf("Unknown sequence detected.\n");
    }
}

void Process_PWM(void) {
    if (measurementReady) {
        measurementReady = 0;

        dutyCycle = ((float)highTime / period) * 100.0;

        // Apply debouncing logic: Ignore small fluctuations in the duty cycle
        if (abs(dutyCycle - lastDutyCycle) < DEBOUNCE_THRESHOLD) {
            return;  // Ignore if the change is too small
        }
        lastDutyCycle = dutyCycle;

        // Handle possible high duty cycles (near 90%)
        if (dutyCycle > 95.0) {
            dutyCycle = 90.0;
        }

        // Debugging print
        printf("Measured Duty Cycle: %.2f%%\n", dutyCycle);

        // Adjusted ranges with slightly increased tolerance
        const float requiredDutyCycleRanges[4][2] = {
            {21.0, 30.0},  // 25% duty cycle range
            {46.0, 55.0},  // 50% duty cycle range
            {71.0, 80.0},  // 75% duty cycle range
            {85.0, 95.0}   // 90% duty cycle range
        };

        // Classification logic
        for (int i = 0; i < 4; i++) {
            if (dutyCycle >= requiredDutyCycleRanges[i][0] && dutyCycle <= requiredDutyCycleRanges[i][1]) {
                float classifiedDuty = (i + 1) * 22.5;
                if (i == 0) classifiedDuty = 25;
                if (i == 1) classifiedDuty = 50;
                if (i == 2) classifiedDuty = 75;
                if (i == 3) classifiedDuty = 90;

                // Debugging print for classification
                printf("Classified Duty Cycle as %.0f%%\n", classifiedDuty);

                // Add sequence detection logic based on current state
                switch (current_state) {
                    case DETECT_START_BIT:
                        if (classifiedDuty == 25) {
                            printf("------------Start Bit Detected----------------\n");
                            current_state = CAPTURE_SEQUENCE;
                            duty_cycle_index = 0;
                            duty_cycles[duty_cycle_index++] = classifiedDuty;
                        }
                        break;

                    case CAPTURE_SEQUENCE:
                        duty_cycles[duty_cycle_index++] = classifiedDuty;
                        printf("--------------Captured Sequence[%d]: %.0f%% ------------\n", duty_cycle_index, classifiedDuty);
                        if (duty_cycle_index == 4) {
                            classify_pd_class(duty_cycles);
                            current_state = IGNORE_PHASE;
                        }
                        break;

                    case IGNORE_PHASE:
                        printf("Ignoring phase until next start bit.\n");
                        // Ignore until you detect the start bit again
                        if (classifiedDuty == 25) {
                            current_state = WAIT_FOR_REPEAT;
                        }
                        break;

                    case WAIT_FOR_REPEAT:
                        if (classifiedDuty == 25) {
                            // Restart sequence detection after a repeat
                            printf("Start Bit Detected after Repeat\n");
                            current_state = CAPTURE_SEQUENCE;
                            duty_cycle_index = 0;
                            duty_cycles[duty_cycle_index++] = classifiedDuty;
                        }
                        break;
                }
                break;
            }
        }
    }
}


int main(void) {

	MXC_Delay(MXC_DELAY_MSEC(5));
    GPIO_Init();
    Timer_Init();

    // Initial classification right after start
    printf("STARING_____ AT :--> \n\t");
    Process_PWM();

    while (1) {
        Process_PWM();
        MXC_Delay(MXC_DELAY_MSEC(250));
    }

    return 0;
}













































